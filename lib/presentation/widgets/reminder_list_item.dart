import 'package:drift/drift.dart' show Value;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart'; // For navigation if needed for edit
import 'package:intl/intl.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:timezone/data/latest_all.dart' as tz_data;

import '../../data/local/database/app_database.dart';
import '../../models/enum.dart';
import '../../providers/database_provider.dart';
import '../../services/notification_service.dart'; // To schedule/cancel notifications
import '../../utils/reminder_utils.dart'; // For date calculation and formatting
// Import the screen route name if navigating from here
import '../../presentation/screens/reminders/reminders_list_screen.dart'; // Example if navigating back to list

// Helper extension for converting Reminder to Companion (if not generated by drift)
// You might already have this if using newer drift versions.
extension ReminderCompanionX on Reminder {
  RemindersCompanion toCompanion(bool nullToAbsent) {
    return RemindersCompanion(
      id: Value(id),
      objectId: Value(objectId),
      objectType: Value(objectType),
      taskName: Value(taskName),
      // Use Value.ofNullable for safety, matching the save logic
      frequencyRule: Value.ofNullable(frequencyRule),
      nextDueDate: Value(nextDueDate),
      notes: Value.ofNullable(notes),
      isActive: Value(isActive),
      creationDate: Value(creationDate),
    );
  }
}

class ReminderListItem extends ConsumerWidget {
  final Reminder reminder;
  final bool showObjectName; // Controls if the object name is displayed

  const ReminderListItem({
    super.key,
    required this.reminder,
    this.showObjectName = true,
  });

  // (Internal provider to fetch object name - kept from previous step)
  static final _objectNameProvider = FutureProvider.autoDispose
      .family<String?, ({int id, ObjectType type})>((ref, params) async {
        final db = ref.read(databaseProvider);
        if (params.type == ObjectType.plant) {
          final plant =
              await (db.select(db.plants)
                ..where((tbl) => tbl.id.equals(params.id))).getSingleOrNull();
          return plant?.name;
        } else {
          final pet =
              await (db.select(db.pets)
                ..where((tbl) => tbl.id.equals(params.id))).getSingleOrNull();
          return pet?.name;
        }
      });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final DateFormat dateFormatter = DateFormat('yyyy-MM-dd');
    final DateFormat timeFormatter = DateFormat('HH:mm');
    final theme = Theme.of(context);
    final now = DateTime.now();
    final location = tz.local;
    final tz.TZDateTime nextDueLocalTz = tz.TZDateTime.from(
      reminder.nextDueDate,
      location,
    );
    // Use TZDateTime for accurate comparison if possible, but DateTime is okay for simple check
    final bool isOverdue =
        reminder.isActive &&
        nextDueLocalTz.isBefore(tz.TZDateTime.now(location));
    // Check if reminder is recurring based on the rule string
    final bool isRecurring =
        reminder.frequencyRule != null &&
        reminder.frequencyRule!.isNotEmpty &&
        reminder.frequencyRule != 'ONCE';

    // Fetch object name if needed
    final objectNameFuture =
        showObjectName
            ? ref.watch(
              _objectNameProvider((
                id: reminder.objectId,
                type: reminder.objectType,
              )),
            )
            : null;

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6.0),
      color:
          !reminder.isActive
              ? Colors.grey[300]
              : (isOverdue ? Colors.red[50] : null),
      child: ListTile(
        leading: Column(
          // Leading icon and status text
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              reminder.objectType == ObjectType.plant
                  ? Icons.local_florist_outlined
                  : Icons.pets_outlined,
              color:
                  reminder.isActive ? theme.colorScheme.primary : Colors.grey,
            ),
            if (!reminder.isActive)
              Text(
                '暂停',
                style: TextStyle(fontSize: 10, color: Colors.grey[600]),
              )
            else if (isOverdue)
              Text(
                '过期',
                style: TextStyle(fontSize: 10, color: Colors.red[700]),
              ),
          ],
        ),
        title: Text(
          // Task name with line-through if inactive
          reminder.taskName,
          style: TextStyle(
            fontWeight: FontWeight.bold,
            decoration: !reminder.isActive ? TextDecoration.lineThrough : null,
            color: reminder.isActive ? null : Colors.grey[600],
          ),
        ),
        subtitle: Column(
          // Subtitle with multiple lines
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Display associated object name (loaded async)
            if (showObjectName && objectNameFuture != null)
              objectNameFuture.when(
                data:
                    (name) => Text(
                      name ?? '未知对象',
                      style: TextStyle(
                        fontSize: 12,
                        color: theme.disabledColor,
                      ),
                    ),
                loading:
                    () => const SizedBox(
                      height: 14,
                      child: Text('...', style: TextStyle(fontSize: 12)),
                    ), // Placeholder
                error:
                    (_, __) => const Text(
                      '错误',
                      style: TextStyle(fontSize: 12, color: Colors.red),
                    ),
              ),
            // Next Due Date display
            Padding(
              // Add padding for better spacing if object name is shown
              padding: EdgeInsets.only(
                top: showObjectName && objectNameFuture != null ? 4.0 : 0,
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.alarm,
                    size: 14,
                    color:
                        isOverdue && reminder.isActive
                            ? Colors.red[700]
                            : Colors.grey[600],
                  ),
                  const SizedBox(width: 4),
                  Text(
                    '${dateFormatter.format(nextDueLocalTz)} ${timeFormatter.format(nextDueLocalTz)}',
                    style: TextStyle(
                      fontSize: 12,
                      color:
                          isOverdue && reminder.isActive
                              ? Colors.red[700]
                              : Colors.grey[600],
                    ),
                  ),
                ],
              ),
            ),
            // Formatted Frequency Rule display (using ReminderUtils)
            if (isRecurring) // Only show for recurring
              Padding(
                padding: const EdgeInsets.only(top: 2.0),
                child: Text(
                  ReminderUtils.formatFrequencyRuleForDisplay(
                    reminder.frequencyRule,
                  ),
                  style: TextStyle(fontSize: 12, color: Colors.grey[600]),
                ),
              ),
            // Notes display (if present)
            if (reminder.notes != null && reminder.notes!.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 4.0),
                child: Text(
                  reminder.notes!,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: TextStyle(fontSize: 12, color: Colors.grey[700]),
                ),
              ),
          ],
        ),
        // Trailing Popup Menu for actions
        trailing: PopupMenuButton<String>(
          tooltip: "更多操作",
          onSelected: (String result) {
            // Handle menu item selection
            switch (result) {
              case 'mark_done':
                _markReminderDone(context, ref, reminder);
                break;
              case 'toggle_active':
                _toggleReminderActive(context, ref, reminder);
                break;
              case 'edit':
                _navigateToEditReminder(context, reminder.id);
                break;
              case 'delete':
                _confirmDeleteReminder(context, ref, reminder);
                break;
            }
          },
          itemBuilder:
              (BuildContext context) => <PopupMenuEntry<String>>[
                // Add Mark Done option only if active
                if (reminder.isActive)
                  const PopupMenuItem<String>(
                    value: 'mark_done',
                    child: ListTile(
                      leading: Icon(Icons.check_circle_outline),
                      title: Text('标记完成'),
                    ),
                  ),
                if (reminder.isActive) const PopupMenuDivider(),
                // Toggle Active/Inactive option
                PopupMenuItem<String>(
                  value: 'toggle_active',
                  child: ListTile(
                    leading: Icon(
                      reminder.isActive
                          ? Icons.pause_circle_outline
                          : Icons.play_circle_outline,
                    ),
                    title: Text(reminder.isActive ? '暂停提醒' : '激活提醒'),
                  ),
                ),
                // Edit option
                const PopupMenuItem<String>(
                  value: 'edit',
                  child: ListTile(
                    leading: Icon(Icons.edit_outlined),
                    title: Text('编辑'),
                  ),
                ),
                // Delete option
                const PopupMenuItem<String>(
                  value: 'delete',
                  child: ListTile(
                    leading: Icon(Icons.delete_outline, color: Colors.red),
                    title: Text('删除', style: TextStyle(color: Colors.red)),
                  ),
                ),
              ],
          icon: const Icon(Icons.more_vert),
        ),
        // Navigate to edit screen on tap as well
        onTap: () {
          _navigateToEditReminder(context, reminder.id);
        },
      ),
    );
  }

  // --- Action Handlers ---

  // Toggle reminder active status
  Future<void> _toggleReminderActive(
    BuildContext context,
    WidgetRef ref,
    Reminder reminder,
  ) async {
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final db = ref.read(databaseProvider);
    final notificationService = ref.read(notificationServiceProvider);
    final bool newActiveState = !reminder.isActive;

    // Use copyWith if available, otherwise create companion manually
    final updatedReminder = reminder.copyWith(isActive: newActiveState);
    // Or: final companion = RemindersCompanion(id: Value(reminder.id), isActive: Value(newActiveState));

    try {
      // Use the companion generated by copyWith or created manually
      await db.updateReminder(
        updatedReminder.toCompanion(false),
      ); // Use extension method or manual companion

      // Schedule or Cancel notification based on new state
      if (newActiveState) {
        // Re-schedule notification only if becoming active
        await notificationService.scheduleReminderNotification(updatedReminder);
      } else {
        // Cancel notification if becoming inactive
        await notificationService.cancelNotification(reminder.id);
      }

      if (context.mounted) {
        // Check context validity
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text('提醒已${newActiveState ? "激活" : "暂停"}')),
        );
      }
    } catch (e) {
      print("Error toggling reminder active state: $e");
      if (context.mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text('操作失败: $e'), backgroundColor: Colors.red),
        );
      }
    }
  }

  // Navigate to edit reminder screen
  void _navigateToEditReminder(BuildContext context, int reminderId) {
    // Use GoRouter or standard Navigator push
    // Ensure the route name 'editReminder' matches your GoRouter config
    context.goNamed(
      'editReminder',
      pathParameters: {'id': reminderId.toString()},
    );
  }

  // Confirm and delete reminder
  Future<void> _confirmDeleteReminder(
    BuildContext context,
    WidgetRef ref,
    Reminder reminder,
  ) async {
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final result = await showDialog<bool>(
      context: context,
      builder:
          (context) => AlertDialog(
            title: const Text('确认删除提醒?'),
            content: Text('确定要删除任务 "${reminder.taskName}" 吗？此操作无法撤销。'),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: const Text('取消'),
              ),
              TextButton(
                style: TextButton.styleFrom(foregroundColor: Colors.red),
                onPressed: () => Navigator.of(context).pop(true),
                child: const Text('删除'),
              ),
            ],
          ),
    );

    if (result == true) {
      final db = ref.read(databaseProvider);
      final notificationService = ref.read(notificationServiceProvider);
      try {
        await notificationService.cancelNotification(
          reminder.id,
        ); // Cancel notification first
        await db.deleteReminder(reminder.id);
        if (context.mounted) {
          // Check context validity
          scaffoldMessenger.showSnackBar(
            const SnackBar(content: Text('提醒已删除')),
          );
        }
      } catch (e) {
        print("Error deleting reminder: $e");
        if (context.mounted) {
          scaffoldMessenger.showSnackBar(
            SnackBar(content: Text('删除失败: $e'), backgroundColor: Colors.red),
          );
        }
      }
    }
  }

  // Mark reminder as done, calculate next date for recurring, or deactivate ONCE
  Future<void> _markReminderDone(
    BuildContext context,
    WidgetRef ref,
    Reminder reminder,
  ) async {
    print("==> START _markReminderDone - Reminder ID: ${reminder.id}");
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final db = ref.read(databaseProvider);
    final notificationService = ref.read(notificationServiceProvider);

    // Ensure timezones are initialized
    try {
      tz_data.initializeTimeZones();
    } catch (_) {}
    final location = tz.local;
    print(
      "--> BEFORE calculateNextDueDate - Rule: ${reminder.frequencyRule}",
    ); // <-- 添加日志 (2)
    // Calculate the next due date using ReminderUtils
    tz.TZDateTime? nextDueDate = ReminderUtils.calculateNextDueDate(
      reminder,
      location: location,
    );
    print(
      "<-- AFTER calculateNextDueDate - Result: $nextDueDate",
    ); // <-- 添加日志 (3)
    try {
      Reminder updatedReminder;

      if (nextDueDate != null) {
        // --- Recurring reminder ---
        print(
          'Calculated next due date for reminder ${reminder.id}: $nextDueDate',
        );
        // Create updated reminder with new date, keep active
        updatedReminder = reminder.copyWith(
          nextDueDate: nextDueDate,
          isActive: true,
        ); // Ensure isActive stays true
        print("--> BEFORE DB Update (Recurring)"); // <-- 添加日志 (4a)
        await db.updateReminder(
          updatedReminder.toCompanion(false),
        ); // Use extension or manual companion
        print("<-- AFTER DB Update (Recurring)"); // <-- 添加日志 (4b)

        print("--> BEFORE Notification Cancel (Recurring)"); // <-- 添加日志 (5a)
        // Reschedule notification
        await notificationService.cancelNotification(reminder.id);
        print("<-- AFTER Notification Cancel (Recurring)"); // <-- 添加日志 (5b)

        print("--> BEFORE Notification Schedule (Recurring)"); // <-- 添加日志 (6a)
        await notificationService.scheduleReminderNotification(updatedReminder);
        print("<-- AFTER Notification Schedule (Recurring)"); // <-- 添加日志 (6b)
        if (context.mounted) {
          print("--> BEFORE SnackBar (Recurring)"); // <-- 添加日志 (7a)
          scaffoldMessenger.showSnackBar(
            SnackBar(content: Text('任务 "${reminder.taskName}" 完成！下次时间已更新。')),
          );
          print("<-- AFTER SnackBar (Recurring)"); // <-- 添加日志 (7b)
        }
      } else {
        // --- ONCE reminder or end of recurrence ---
        print('Marking ONCE reminder ${reminder.id} as inactive.');
        // Create updated reminder, set inactive
        updatedReminder = reminder.copyWith(isActive: false);
        print("--> BEFORE DB Update (Once/End)"); // <-- 添加日志 (8a)
        await db.updateReminder(updatedReminder.toCompanion(false));
        print("<-- AFTER DB Update (Once/End)"); // <-- 添加日志 (8b)
        print("--> BEFORE Notification Cancel (Once/End)"); // <-- 添加日志 (9a)

        // Cancel notification as it's done or inactive
        await notificationService.cancelNotification(reminder.id);
        print("<-- AFTER Notification Cancel (Once/End)"); // <-- 添加日志 (9b)

        if (context.mounted) {
          print("--> BEFORE SnackBar (Once/End)"); // <-- 添加日志 (10a)
          scaffoldMessenger.showSnackBar(
            SnackBar(content: Text('任务 "${reminder.taskName}" 已完成！')),
          );
          print("<-- AFTER SnackBar (Once/End)"); // <-- 添加日志 (10b)
        }
      }

      // Optional: Add a log entry
      // ...
    } catch (e) {
      print("Error marking reminder done: $e");
      if (context.mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text('标记完成失败: $e'), backgroundColor: Colors.red),
        );
      }
    }
  }
}
